{"ast":null,"code":"import _Promise from \"@babel/runtime-corejs2/core-js/promise\";\nimport Axios from 'axios'; // import { Message } from 'antd'\n\nvar cancel,\n    promiseArr = {};\nvar CancelToken = Axios.CancelToken;\nvar axios = Axios.create({\n  // 10秒请求超时\n  timeout: 10000,\n  // `withCredentials` 表示跨域请求时是否需要使用凭证\n  withCredentials: false,\n  // `responseType` 表示服务器响应的数据类型，可以是 'arraybuffer', 'blob', 'document', 'json', 'text', 'stream'\n  responseType: 'json',\n  responseEncoding: 'utf8',\n  // `validateStatus` 定义对于给定的HTTP 响应状态码是 resolve 或 reject  promise 。如果 `validateStatus` 返回 `true` (或者设置为 `null` 或 `undefined`)，promise 将被 resolve; 否则，promise 将被 rejecte\n  validateStatus: function validateStatus(status) {\n    return status >= 200 && status < 300;\n  }\n}); // 请求拦截器\n// axios.interceptors.request.use(\n//   function (config) {\n//     console.log(cancel)\n//     if (promiseArr[config.url]) {\n//       promiseArr[config.url]('操作取消')\n//       promiseArr[config.url] = cancel\n//       console.error('请求多次提交')\n//     } else {\n//       promiseArr[config.url] = cancel\n//       console.log(cancel)\n//     }\n//     return config\n//   },\n//   function (error) {\n//     return Promise.reject(error)\n//   }\n// )\n// 响应拦截器\n\naxios.interceptors.response.use(function (res) {\n  return res;\n}, function (error) {\n  var errorMsg;\n\n  if (error && error.response) {\n    var status = error.response.status;\n\n    switch (status) {\n      case 400:\n        errorMsg = error.response.data.msg;\n        break;\n\n      case 401:\n        errorMsg = '请求要求用户的身份认证';\n        break;\n\n      case 402:\n        errorMsg = '保留将来使用';\n        break;\n\n      case 403:\n        errorMsg = '请求被服务端拒绝';\n        break;\n\n      case 404:\n        errorMsg = '请求资源无法找到';\n        break;\n\n      case 405:\n        errorMsg = '请求方法被禁止';\n        break;\n\n      case 406:\n        errorMsg = '服务端无法根据客户端请求的内容特性完成请求';\n        break;\n\n      case 407:\n        errorMsg = '应当使用代理进行授权';\n        break;\n\n      case 408:\n        errorMsg = '请求时间过长';\n        break;\n\n      case 500:\n        errorMsg = '服务端内部错误';\n        break;\n\n      case 501:\n        errorMsg = '服务端不支持请求的功能';\n        break;\n\n      case 502:\n        errorMsg = '无效的响应';\n        break;\n\n      case 503:\n        errorMsg = '超载或系统维护无法处理请求';\n        break;\n\n      case 505:\n        errorMsg = '服务器不支持请求的HTTP协议的版本';\n        break;\n\n      default:\n        break;\n    }\n  } else {\n    errorMsg = '连接服务器失败';\n  }\n\n  console.error(errorMsg);\n  return _Promise.reject(error);\n});\nexport default {\n  get: function get(url) {\n    var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return axios({\n      method: 'GET',\n      url: url,\n      params: params,\n      cancelToken: new CancelToken(function (c) {\n        cancel = c;\n      })\n    }).then(function (res) {\n      return _Promise.resolve(res.data);\n    });\n  }\n};","map":{"version":3,"sources":["/Users/kite/sub/react/ynode/common/js/axios.js"],"names":["Axios","cancel","promiseArr","CancelToken","axios","create","timeout","withCredentials","responseType","responseEncoding","validateStatus","status","interceptors","response","use","res","error","errorMsg","data","msg","console","reject","get","url","params","method","cancelToken","c","then","resolve"],"mappings":"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","sourcesContent":["import Axios from 'axios'\n// import { Message } from 'antd'\n\nlet cancel,\n  promiseArr = {}\n\nconst CancelToken = Axios.CancelToken\n\nconst axios = Axios.create({\n  // 10秒请求超时\n  timeout: 10000,\n\n  // `withCredentials` 表示跨域请求时是否需要使用凭证\n  withCredentials: false,\n\n  // `responseType` 表示服务器响应的数据类型，可以是 'arraybuffer', 'blob', 'document', 'json', 'text', 'stream'\n  responseType: 'json',\n\n  responseEncoding: 'utf8',\n\n  // `validateStatus` 定义对于给定的HTTP 响应状态码是 resolve 或 reject  promise 。如果 `validateStatus` 返回 `true` (或者设置为 `null` 或 `undefined`)，promise 将被 resolve; 否则，promise 将被 rejecte\n  validateStatus: function (status) {\n    return status >= 200 && status < 300\n  }\n})\n\n// 请求拦截器\n// axios.interceptors.request.use(\n//   function (config) {\n//     console.log(cancel)\n//     if (promiseArr[config.url]) {\n//       promiseArr[config.url]('操作取消')\n//       promiseArr[config.url] = cancel\n//       console.error('请求多次提交')\n//     } else {\n//       promiseArr[config.url] = cancel\n//       console.log(cancel)\n//     }\n//     return config\n//   },\n//   function (error) {\n//     return Promise.reject(error)\n//   }\n// )\n\n// 响应拦截器\naxios.interceptors.response.use(\n  res => {\n    return res\n  },\n  error => {\n    let errorMsg\n    if (error && error.response) {\n      const status = error.response.status\n      switch (status) {\n        case 400:\n          errorMsg = error.response.data.msg\n          break\n        case 401:\n          errorMsg = '请求要求用户的身份认证'\n          break\n        case 402:\n          errorMsg = '保留将来使用'\n          break\n        case 403:\n          errorMsg = '请求被服务端拒绝'\n          break\n        case 404:\n          errorMsg = '请求资源无法找到'\n          break\n        case 405:\n          errorMsg = '请求方法被禁止'\n          break\n        case 406:\n          errorMsg = '服务端无法根据客户端请求的内容特性完成请求'\n          break\n        case 407:\n          errorMsg = '应当使用代理进行授权'\n          break\n        case 408:\n          errorMsg = '请求时间过长'\n          break\n        case 500:\n          errorMsg = '服务端内部错误'\n          break\n        case 501:\n          errorMsg = '服务端不支持请求的功能'\n          break\n        case 502:\n          errorMsg = '无效的响应'\n          break\n        case 503:\n          errorMsg = '超载或系统维护无法处理请求'\n          break\n        case 505:\n          errorMsg = '服务器不支持请求的HTTP协议的版本'\n          break\n        default:\n          break\n      }\n    } else {\n      errorMsg = '连接服务器失败'\n    }\n    console.error(errorMsg)\n    return Promise.reject(error)\n  }\n)\n\nexport default {\n  get(url, params = {}) {\n    return axios({\n      method: 'GET',\n      url,\n      params,\n      cancelToken: new CancelToken(c => {\n        cancel = c\n      })\n    }).then(res => {\n      return Promise.resolve(res.data)\n    })\n  }\n}"]},"metadata":{},"sourceType":"module"}